var documenterSearchIndex = {"docs":
[{"location":"style/#Style-1","page":"Code Style","title":"Style","text":"","category":"section"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"JuliaFormatter consists of 3 stages:","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Prettify\nNest\nPrint","category":"page"},{"location":"style/#Prettify-1","page":"Code Style","title":"Prettify","text":"","category":"section"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Normalizes the .jl file into a canonical format. All unnecessary whitespace is removed, code is properly indented, and everything which can fit on a single line, does.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"This stage creates a PTree.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"(all examples assume indentation of 4 spaces)","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Examples:","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Functions, macros, structs with no arguments are placed on a single line. This also applies to abstract and primitive types.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"function  foo\n end\n\n->\n\nfunction foo end","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Functions calls foo(args), tuples (args), arrays [args], braces {args}, struct or where definitions Foo{args} are placed on a single line. Unless the arguments are surrounded by {} each argument is separated by a single space.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"f(\na,b\n,c )\n\n->\n\nf(a, b, c)","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Blocks and their bodies are properly indented.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"begin\n  a\n    b\nc\n       end\n\n->\n\nbegin\n    a\n    b\n    c\nend\n\n# ---\n\nstruct Foo{A, B}\n a::A\n  b::B\nend\n\n->\n\nstruct Foo{A,B}\n    a::A\n    b::B\nend","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Binary calls are placed on a single line. The vast majority of operators and arguments are separated by a single space with the exception of colons and operations inside an indexing expression.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"a+b\n\n-> \n\na + b\n\n# ---\n\na : a : c\n\n->\n\na:b:c\n\n# ---\n\nlist[a + b]\n\n->\n\nlist[a+b]","category":"page"},{"location":"style/#Nesting-1","page":"Code Style","title":"Nesting","text":"","category":"section"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Lines going over the maximum margin are split into multiple lines such that they fit inside the margin.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"This stage mutates the PTree generated from prettification.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Most expressions are nested left to right with the exception of binary operations and conditionals which are nested right to left.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Examples:","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"arg1 + arg2\n\n->\n\narg1 + \narg2\n\n# ---\n\ncond ? e1 : e2\n\n->\n\ncond ? e1 :\ne2\n\n->\n\ncond ? \ne1 :\ne2","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Short function definitions and certain blocks - for, while, do, try, if, or let with arguments are initially nested such that the RHS (after =) is placed on the next line.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"foo() = body\n\n->\n\nfoo() =\n    body\n\n# ---\n\nfoo = if this_is_a_condition\n  a\nelse\n  b\nend\n\n->\n\nfoo =\n    if this_is_a_condition\n        a\n    catch e\n        b\n    end","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"Function Calls f(...) (also applies to F{}, {}, (), [])","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"The arguments are indented. The arguments will never pass the initial opening punctuation, i.e. ( by more than a single space. If a comment is detected in between arguments nesting will be forced.","category":"page"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"f(arg1, arg2, arg3)\n\n->\n\nf(\n  arg1,\n  arg2,\n  arg3,\n)\n\n# ---\n\nfunction longfunctionname_that_is_long(lots, of, args, even, more, args)\n    body\nend\n\n->\n\nfunction longfunctionname_that_is_long(\n    lots, \n    of, \n    args,\n    even, \n    more, \n    args,\n)\n    body\nend\n\n# ---\n\nvar = foo(\n    a, b, # comment\n    c,\n)\n\n->\n\nvar = foo(\n    a,\n    b, # comment\n    c,\n)","category":"page"},{"location":"style/#Print-1","page":"Code Style","title":"Print","text":"","category":"section"},{"location":"style/#","page":"Code Style","title":"Code Style","text":"This stage prints the mutated PTree.","category":"page"},{"location":"transforms/#Syntax-Tree-Transformations-1","page":"Syntax Transforms","title":"Syntax Tree Transformations","text":"","category":"section"},{"location":"transforms/#for-in-vs.-for-1","page":"Syntax Transforms","title":"for in vs. for =","text":"","category":"section"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"By default if the RHS is a range, i.e. 1:10 then for in is converted to for =. Otherwise for = is converted to for in. See this issue for the rationale and further explanation.","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"Alternative to the above - setting always_for_in to true, i.e. format_text(..., always_for_in = true) will always convert = to in even if the RHS is a range.","category":"page"},{"location":"transforms/#Trailing-Commas-1","page":"Syntax Transforms","title":"Trailing Commas","text":"","category":"section"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"If an iterable expression is nested a trailing comma is added to the last argument. The trailing comma is removed if the expressions is unnested:","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"f(a, b, c)\n\n->\n\nf(\n  a,\n  b,\n  c,\n)","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Trailing-Semicolons-1","page":"Syntax Transforms","title":"Trailing Semicolons","text":"","category":"section"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a matrix expression is nested the semicolons are removed.","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"[1 0; 0 1]\n\n->\n\n[\n 1 0\n 0 1\n]","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Leading-and-trailing-0s-for-float-literals-1","page":"Syntax Transforms","title":"Leading and trailing 0s for float literals","text":"","category":"section"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a float literal is missing a trailing 0 it is added:","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"a = 1.\n\n->\n\na = 1.0","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a float literal is missing a leading 0 it is added:","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"a = .1\n\n->\n\na = 0.1","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Surround-where-arguments-with-curly-brackets-1","page":"Syntax Transforms","title":"Surround where arguments with curly brackets","text":"","category":"section"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"If the arguments of a where call are not surrounded by curly brackets, they are added:","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"foo(x::T) where T = ...\n\n->\n\nfoo(x::T) where {T} = ...","category":"page"},{"location":"transforms/#","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"#JuliaFormatter.jl-1","page":"Introduction","title":"JuliaFormatter.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Build Status)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Width-sensitive formatter for Julia code. Inspired by gofmt, refmt, and black. Built with CSTParser.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"]add JuliaFormatter","category":"page"},{"location":"#Quick-Start-1","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using JuliaFormatter\n\n# Recursively formats all Julia files in the current directory\njulia> format(\".\")","category":"page"},{"location":"#Usage-1","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"JuliaFormatter exports format_text, format_file and format:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"format_text(\n    text::AbstractString;\n    indent = 4,\n    margin = 92,\n    always_for_in = false,\n    whitespace_typedefs::Bool = false,\n    whitespace_ops_in_indices::Bool = false,\n)\n\nformat_file(\n    file::AbstractString;\n    overwrite = true,\n    verbose = false,\n    indent = 4,\n    margin = 92,\n    always_for_in = false,\n    whitespace_typedefs::Bool = false,\n    whitespace_ops_in_indices::Bool = false,\n)\n\nformat(\n    paths...;\n    overwrite = true,\n    verbose = false,\n    indent = 4,\n    margin = 92,\n    always_for_in = false,\n    whitespace_typedefs::Bool = false,\n    whitespace_ops_in_indices::Bool = false,\n)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The text argument to format_text is a string containing the code to be formatted; the formatted code is retuned as a new string. The file argument to format_file is the path of a file to be formatted. The format function is either called with a singe string to format if it is a .jl file or to recuse into looking for .jl files if it is a directory. It can also be called with a collection of such paths to iterate over.","category":"page"},{"location":"#File-Options-1","page":"Introduction","title":"File Options","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If overwrite is true the file will be reformatted in place, overwriting the existing file; if it is false, the formatted version of foo.jl will be written to foo_fmt.jl instead.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If verbose is true details related to formatting the file will be printed to stdout.","category":"page"},{"location":"#Formatting-Options-1","page":"Introduction","title":"Formatting Options","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"indent - the number of spaces used for an indentation.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"margin - the maximum length of a line. Code exceeding this margin will be formatted across multiple lines.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If always_for_in is true = is always replaced with in if part of a for loop condition.  For example, for i = 1:10 will be transformed to for i in 1:10.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If whitespace_typedefs is true, whitespace is added for type definitions. Make this true if you prefer Union{A <: B, C} to Union{A<:B,C}.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If whitespace_ops_in_indices is true, whitespace is added for binary operations in indices. Make this true if you prefer arr[a + b] to arr[a+b]. Additionally, if there's a colon : involved, parenthesis will be added to the LHS and RHS. Example: arr[(i1 + i2):(i3 + i4)] instead of arr[i1+i2:i3+i4].","category":"page"}]
}
